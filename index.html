<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual de Bolso: Revisão de React Native</title>
    <!-- Carrega Tailwind CSS para estilo responsivo e moderno -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Configuração da fonte Inter (padrão) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        :root {
            --primary-color: #10b981; /* Esmeralda 500 para feedback correto */
            --secondary-color: #f87171; /* Vermelho 400 para feedback incorreto */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Fundo escuro (Slate 900) */
            color: #e2e8f0; /* Texto claro (Slate 200) */
        }

        /* Estilos personalizados para o Toast de feedback */
        #feedback-toast {
            transition: all 0.3s ease-in-out;
            transform: translateY(100%);
            bottom: 0;
            /* Garante que o texto da explicação longa não fique muito apertado */
            padding-right: 1.5rem; 
        }

        #feedback-toast.show {
            transform: translateY(0);
        }

        /* Estilo para a opção correta após o erro */
        .correct-answer-highlight {
            background-color: #065f46; /* Verde escuro para destaque */
            border-left: 4px solid var(--primary-color);
        }

        /* Estilo para o botão de opção no hover/focus */
        .option-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Estilo para renderizar quebras de linha em textos do quiz (opcional) */
        .whitespace-pre-line {
            white-space: pre-line;
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-6 flex justify-center items-start">

    <!-- Container Principal do Manual -->
    <div id="app-container" class="w-full max-w-2xl bg-slate-800 p-6 sm:p-8 rounded-xl shadow-2xl space-y-8 mt-4 mb-24">
        
        <!-- Cabeçalho e Progresso -->
        <header class="text-center space-y-2">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-white">Manual de Bolso React Native</h1>
            <p id="progress-text" class="text-sm font-medium text-slate-400">Questão 1 de 20</p>
            <div id="progress-bar-container" class="w-full h-2 bg-slate-700 rounded-full overflow-hidden">
                <div id="progress-bar" class="h-full bg-emerald-500 transition-all duration-500 ease-out" style="width: 5%;"></div>
            </div>
        </header>

        <!-- Área da Questão -->
        <section id="quiz-section" class="space-y-6">
            <div class="bg-slate-700 p-5 rounded-lg border-l-4 border-emerald-500 shadow-md">
                <p id="question-text" class="text-lg font-semibold text-slate-100 leading-relaxed whitespace-pre-line">
                    <!-- O texto da pergunta será injetado aqui pelo JS -->
                </p>
            </div>

            <!-- Opções de Resposta -->
            <div id="options-container" class="space-y-4">
                <!-- As opções serão injetadas aqui pelo JS -->
            </div>

            <!-- Botão Próxima Questão (Escondido inicialmente) -->
            <button id="next-button" 
                    class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg shadow-lg transition duration-200 opacity-0 pointer-events-none"
                    onclick="nextQuestion()">
                Próxima Questão <span aria-hidden="true">&rarr;</span>
            </button>
        </section>
    </div>

    <!-- Feedback Toast (Alerta personalizado - Substitui alert()) -->
    <div id="feedback-toast" 
         class="fixed left-0 right-0 mx-auto w-full max-w-md p-4 rounded-t-xl shadow-2xl z-50 flex flex-col justify-start sm:justify-between items-start sm:items-center space-y-2"
         style="box-shadow: 0 -5px 15px rgba(0,0,0,0.5);">
        <p id="feedback-message" class="font-semibold text-left text-sm sm:text-base"></p>
        <button id="toast-button" class="py-1 px-3 bg-white text-sm font-bold rounded-lg hidden" onclick="hideToast()"></button>
    </div>

    <!-- Modal de Fim do Quiz -->
    <div id="finish-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm hidden items-center justify-center p-4 z-[100]">
        <div class="bg-slate-800 p-8 rounded-xl max-w-sm w-full text-center space-y-5 border-t-4 border-emerald-500">
            <h2 class="text-3xl font-bold text-emerald-400">Revisão Concluída!</h2>
            <p class="text-slate-300">Você revisou <span id="final-total-questions" class="font-bold"></span> conceitos de React Native.</p>
            <p class="text-lg font-extrabold text-white">Seu desempenho: <span id="final-score" class="text-emerald-400">0</span> / <span id="final-max-score">0</span></p>
            <button class="w-full py-3 bg-emerald-600 hover:bg-emerald-700 text-white font-bold rounded-lg transition duration-200" onclick="restartQuiz()">
                Revisar Novamente
            </button>
        </div>
    </div>


    <script>
        // Dados do Quiz (Todas as 20 Questões extraídas do PDF DOC-20250930-WA0200..pdf)
        const quizData = [
            {
                id: 1,
                question: "Em ambientes de desenvolvimento mobile, o React Native destaca-se por permitir a construção de interfaces utilizando componentes reutilizáveis e estilização flexível. Um dos principais recursos para a organização visual de elementos é o **Flexbox**, que distribui os componentes na tela com base em regras como alinhamento, espaçamento e proporção. A responsividade, fundamental para diferentes tamanhos de dispositivos, é garantida por propriedades como *justifyContent*, *alignItems* e *flex*. Essa abordagem favorece a construção de interfaces coerentes e adaptáveis, melhorando a experiência do usuário final e otimizando o tempo de desenvolvimento.\n\nCom base no texto, assinale a alternativa que expressa corretamente o papel do Flexbox no React Native:",
                options: [
                    "A) Flexbox é responsável por gerenciar a navegação entre diferentes telas de um aplicativo.",
                    "B) Flexbox é usado para importar bibliotecas externas e componentes nativos no React Native.",
                    "C) Flexbox permite criar interfaces estáticas e inflexíveis, mantendo o controle visual absoluto.",
                    "D) Flexbox organiza visualmente os elementos, garantindo responsividade e adaptação a diferentes dispositivos.",
                    "E) Flexbox é um recurso exclusivo de componentes nativos, não aplicável em componentes personalizados."
                ],
                answer: "D",
                explanation: "O Flexbox é fundamental para a **organização visual e responsividade** dos elementos, adaptando-os a diferentes tamanhos de tela. Ele não tem relação com navegação ou importação de bibliotecas."
            },
            {
                id: 2,
                question: "O componente **<View>** no React Native atua como contêiner principal para a construção de interfaces. Ele permite agrupar outros elementos visuais, organizar a disposição dos itens na tela e aplicar estilos, como margens, alinhamentos e espaçamentos. Por sua semelhança funcional com a <div> do HTML, o <View> é de fácil assimilação para desenvolvedores oriundos do ambiente web. Sua flexibilidade permite a criação de estruturas simples ou complexas, o que o torna essencial em praticamente todos os projetos desenvolvidos com React Native.\n\nCom base no texto, é correto afirmar que:",
                options: [
                    "A) O componente <View> possui funcionalidade equivalente ao <Text> no HTML.",
                    "B) <View> deve ser usado apenas em projetos simples, por causa de sua limitação de recursos.",
                    "C) O uso do <View> é restrito a estilos fixos, sem suporte à responsividade.",
                    "D) O <View> permite criar estruturas organizadas, adaptáveis e estilizadas, similar à <div> no HTML.",
                    "E) O <View> é utilizado exclusivamente para renderizar listas e coleções de dados."
                ],
                answer: "D",
                explanation: "O `<View>` funciona de forma semelhante à **<div>** do HTML: agrupa, organiza e aplica estilos aos elementos, e é essencial em praticamente todos os projetos."
            },
            {
                id: 3,
                question: "O hook **useState** é amplamente utilizado no React Native para gerenciar valores mutáveis na interface. Ele possibilita armazenar e atualizar estados em componentes funcionais, refletindo essas alterações automaticamente na renderização. Ao utilizar o useState, o desenvolvedor recebe uma variável de estado e uma função que permite atualizá-la. Assim, é possível criar interações dinâmicas com o usuário, sem a necessidade de manipulação direta do DOM ou de estruturas complexas.\n\nCom base nas informações do texto, é correto afirmar que:",
                options: [
                    "A) O hook useState é responsável pela navegação entre telas em React Native.",
                    "B) useState atualiza os dados do backend sem alterar o estado da interface.",
                    "C) useState permite o controle reativo de variáveis de estado, refletindo suas mudanças na interface.",
                    "D) O uso do useState é obrigatório em todos os componentes React Native.",
                    "E) O hook useState é utilizado apenas em componentes de classe no React Native."
                ],
                answer: "C",
                explanation: "O `useState` controla variáveis de estado de forma **reativa**, atualizando a interface automaticamente sempre que o estado muda. Ele é exclusivo de componentes funcionais."
            },
            {
                id: 4,
                question: "O React Native possui integração nativa com o **Expo**, uma ferramenta que visa acelerar o desenvolvimento e testes de aplicações. Um de seus principais diferenciais é a eliminação da necessidade de configurar emuladores ou ambientes nativos complexos. Com o aplicativo Expo Go, o desenvolvedor pode escanear um QR Code e visualizar o aplicativo em tempo real no dispositivo físico. Isso reduz significativamente o tempo de prototipagem, favorecendo testes rápidos e ajustes imediatos durante o desenvolvimento.\n\nCom base no texto, conclui-se que o Expo:",
                options: [
                    "A) Exige configurações avançadas para execução do aplicativo em tempo real.",
                    "B) Depende exclusivamente de um emulador Android para testar aplicativos React Native.",
                    "C) Facilita o desenvolvimento ao permitir a visualização imediata do app por meio do Expo Go.",
                    "D) Substitui a necessidade do React Native para criar interfaces móveis.",
                    "E) Não permite testar aplicações em dispositivos físicos."
                ],
                answer: "C",
                explanation: "A grande vantagem do Expo é visualizar o app em **tempo real** no celular usando Expo Go, escaneando um QR Code, o que elimina a configuração avançada de emuladores."
            },
            {
                id: 5,
                question: "A interação do usuário com aplicativos móveis geralmente envolve o acionamento de botões, ícones e gestos. No React Native, o componente **<TouchableOpacity>** é amplamente utilizado para criar botões personalizados com feedback visual. Ele permite alterar a opacidade do elemento durante o toque, além de permitir total controle estético, como inserção de ícones, cores e tamanhos. Isso o torna uma alternativa mais versátil ao componente <Button>, que possui uma aparência mais padronizada e com menos opções de personalização.\n\nA principal vantagem do uso do <TouchableOpacity> em relação ao <Button> é:",
                options: [
                    "A) Sua capacidade de substituir automaticamente outros componentes de interação.",
                    "B) Sua vantagem é criar botões personalizados, com controle de estilo e feedback visual ao toque.",
                    "C) Seu uso é exclusivo para plataformas iOS, otimizando o design.",
                    "D) Oferece suporte nativo e exclusivo a animações complexas.",
                    "E) É restrito a ser usado apenas em componentes funcionais do React Native."
                ],
                answer: "B",
                explanation: "O `<TouchableOpacity>` permite **personalização total de estilo** e fornece feedback visual (opacidade reduzida) ao toque, sendo mais versátil que o `<Button>`."
            },
            {
                id: 6,
                question: "No React Native, o sistema de layout baseado em **Flexbox** oferece ao desenvolvedor a possibilidade de criar interfaces adaptáveis e organizadas. Utilizando propriedades como *flexDirection*, *justifyContent* e *alignItems*, é possível alinhar elementos na tela conforme a necessidade do projeto. O Flexbox torna desnecessário o uso de cálculos manuais de espaçamento e se adapta automaticamente a diferentes resoluções e orientações de tela. Essa característica é essencial para garantir uma boa experiência de usuário em dispositivos com variadas dimensões, desde smartphones até tablets. Dessa forma, o domínio dessas propriedades é considerado uma habilidade técnica fundamental no desenvolvimento mobile moderno.\n\nCom base no texto, analise as afirmações a seguir:\n\nI. O Flexbox permite alinhas os elementos na tela tanto na direção vertical quanto na horizontal.\nII. Propriedades como justifyContent e alignItems garantem controle preciso sobre o posicionamento dos elementos.\nIII. O Flexbox substitui a necessidade de usar componentes como <View> ou <Text> no React Native.\nIV. O Flexbox é útil para tornar a interface responsiva a diferentes tamanhos de tela.\n\nAssinale a alternativa correta:",
                options: [
                    "A) I, II e III, apenas.",
                    "B) I, III e IV, apenas.",
                    "C) II, III e IV, apenas.",
                    "D) I, II e IV, apenas.",
                    "E) I, II, III e IV."
                ],
                answer: "D",
                explanation: "As afirmações I, II e IV estão corretas. A afirmação III está incorreta, pois o Flexbox **organiza o layout dentro** de componentes como `<View>` e `<Text>`, mas não os substitui."
            },
            {
                id: 7,
                question: "O componente **<Text>** no React Native é utilizado para exibir qualquer tipo de conteúdo textual em uma aplicação. Embora pareça simples, ele possui diversas propriedades que permitem customização avançada, como tamanho da fonte, peso, cor, alinhamento e espaçamento. Além disso, o <Text> pode conter elementos aninhados, como outros textos ou até mesmo ícones, desde que compatíveis. Seu uso correto é fundamental para garantir legibilidade, acessibilidade e estética em interfaces móveis. A manipulação inadequada do texto pode comprometer a usabilidade, especialmente em dispositivos com telas menores.\n\nCom base no texto, analise as afirmações a seguir:\n\nI. O componente <Text> permite a customização completa da aparência textual por meio de estilos.\nII. Elementos aninhados dentro de um <Text> devem ser obrigatoriamente imagens externas.\nIII. A utilização correta do <Text> é essencial para garantir legibilidade e boa usabilidade.\nIV. O <Text> pode ser estilizado com propriedades como cor, tamanho e alinhamento.\n\nAssinale a alternativa correta:",
                options: [
                    "A) I, III e IV, apenas.",
                    "B) II, III e IV, apenas.",
                    "C) I, II e IV, apenas.",
                    "D) I, II e III, apenas.",
                    "E) I, II, III e IV."
                ],
                answer: "A",
                explanation: "As afirmações I, III e IV estão corretas. A afirmação II está incorreta, pois elementos aninhados em `<Text>` podem ser outros `<Text>` ou **ícones**, não obrigatoriamente imagens externas."
            },
            {
                id: 8,
                question: "O React Native oferece ferramentas que permitem desenvolver aplicativos móveis de forma mais rápida e com menos configuração. Entre essas ferramentas, destaca-se o **Expo**, que fornece um conjunto de bibliotecas e um ambiente de execução padronizado. Com o Expo Go, o desenvolvedor pode escanear um QR Code e visualizar o app diretamente no celular, sem compilar o projeto nativamente. O uso do Expo é ideal em projetos iniciais, MVPs e ambientes educacionais, onde a agilidade é mais importante que a personalização. No entanto, para recursos que exigem acesso profundo ao hardware, pode ser necessário 'ejetar' o projeto e usar uma abordagem nativa.\n\nCom base no texto, analise as afirmações a seguir:\n\nI. O Expo permite rodar aplicativos diretamente no celular, sem necessidade de emuladores.\nII. O uso do Expo dispensa completamente qualquer conhecimento sobre programação nativa.\nIII. Para utilizar sensores ou recursos avançados do aparelho, pode ser necessário sair do ambiente do Expo.\nIV. O Expo é especialmente útil em projetos iniciais, MVPs e contextos de aprendizagem.\n\nAssinale a alternativa correta:",
                options: [
                    "A) I, III e IV, apenas.",
                    "B) II, III e IV, apenas.",
                    "C) I, II e IV, apenas.",
                    "D) I, II e III, apenas.",
                    "E) I, II, III e IV."
                ],
                answer: "A",
                explanation: "As afirmações I, III e IV estão corretas. A afirmação II está incorreta, pois, embora o Expo simplifique, ele **não dispensa totalmente** o conhecimento de programação nativa, especialmente para recursos avançados."
            },
            {
                id: 9,
                question: "O React Native oferece diversos componentes para capturar interações do usuário, sendo o **<TouchableOpacity>** um dos mais flexíveis. Ele permite criar áreas clicáveis personalizadas, com a possibilidade de alterar o estilo visual no momento do toque. A opacidade diminuída, aplicada durante a interação, é um recurso que fornece feedback tátil ao usuário. Ao contrário do <Button>, que tem um estilo mais rígido, o <TouchableOpacity> pode ser completamente customizado, incluindo uso de imagens, ícones e animações, o que o torna ideal para interfaces modernas e mais ricas visualmente.\n\nCom base no texto, analise as afirmações a seguir:\n\nI. O <TouchableOpacity> fornece feedback visual ao alterar sua opacidade quando pressionado.\nII. O componente permite a inserção de qualquer tipo de conteúdo visual, como imagens e ícones.\nIII. O <Button> oferece mais opções de personalização do que o <TouchableOpacity>.\nIV. A principal vantagem do <TouchableOpacity> é sua flexibilidade estética.\n\nAssinale a alternativa correta:",
                options: [
                    "A) I, II e IV, apenas.",
                    "B) I, III e IV, apenas.",
                    "C) II, III e IV, apenas.",
                    "D) I, II e III, apenas.",
                    "E) I, II, III e IV."
                ],
                answer: "A",
                explanation: "As afirmações I, II e IV estão corretas. A afirmação III está incorreta: o `<TouchableOpacity>` é que é **mais flexível** e oferece mais personalização do que o `<Button>`."
            },
            {
                id: 10,
                question: "O uso do hook **useEffect** no React Native permite lidar com efeitos colaterais, como chamadas a APIs, timers e atualizações externas ao ciclo de renderização normal. Ele é disparado de acordo com as dependências definidas no array passado como segundo argumento. Esse comportamento torna possível controlar exatamente quando o efeito será executado, como na montagem ou atualização do componente. Além disso, o useEffect pode retornar uma função de limpeza, utilizada na desmontagem do componente, evitando vazamentos de memória ou comportamentos inesperados em loops de renderização.\n\nCom base no texto, analise as afirmações a seguir:\n\nI. O useEffect pode ser usado para executar funções na montagem, atualização ou desmontagem de um componente.\nII. O useEffect permite chamadas a APIs e configuração de timers.\nIII. O hook useEffect é ativado automaticamente sempre que o usuário interage com a interface.\nIV. A função de retorno do useEffect serve para limpeza de efeitos colaterais.\n\nAssinale a alternativa correta:",
                options: [
                    "A) I, II e IV, apenas.",
                    "B) I, III e IV, apenas.",
                    "C) II, III e IV, apenas.",
                    "D) I, II e III, apenas.",
                    "E) I, II, III e IV."
                ],
                answer: "A",
                explanation: "As afirmações I, II e IV estão corretas. A afirmação III está incorreta, pois o `useEffect` é ativado conforme as **dependências definidas** (array), não a cada interação do usuário."
            },
            {
                id: 11,
                question: "O React Native adota o sistema de layout Flexbox como padrão para disposição dos elementos na tela. Isso permite que desenvolvedores criem interfaces responsivas, adaptadas a múltiplos tamanhos de tela, sem a necessidade de cálculos manuais de posição. O Flexbox trabalha com os eixos horizontal e vertical para alinhar e distribuir os componentes, tornando possível a criação de interfaces fluidas e adaptáveis. Elementos como *justifyContent*, *alignItems* e *flex* são amplamente usados para definir o comportamento visual em relação aos espaços disponíveis.\n\nConsiderando as informações apresentadas, avalie as asserções a seguir e a relação proposta entre elas:\n\nI. O Flexbox permite criar interfaces adaptáveis, alinhando elementos nos eixos principais de forma responsiva.\n**PORQUE**\nII. Propriedades como justifyContent e alignItems permitem o controle preciso da posição dos elementos nos eixos horizontal e vertical.\n\nA respeito dessas asserções, assinale a opção correta:",
                options: [
                    "A) As asserções I e II são proposições verdadeiras, e a II é uma justificativa correta da I.",
                    "B) As asserções I e II são proposições verdadeiras, mas a II não é uma justificativa correta da I.",
                    "C) A asserção I é uma proposição verdadeira, e a II é uma proposição falsa.",
                    "D) A asserção I é uma proposição falsa, e a II é uma proposição verdadeira.",
                    "E) As asserções I e II são proposições falsas."
                ],
                answer: "A",
                explanation: "Ambas são verdadeiras e a Asserção II, ao citar *justifyContent* e *alignItems* (propriedades chave do Flexbox), **justifica** como a Asserção I (criação de interfaces adaptáveis e responsivas) é alcançada."
            },
            {
                id: 12,
                question: "O componente **<FlatList>** em React Native é usado para renderizar grandes quantidades de dados de forma performática. A principal vantagem desse componente é o uso de renderização sob demanda (*lazy loading*), que carrega apenas os itens visíveis na tela, economizando memória e processamento. Esse comportamento difere de listas comuns, que renderizam todos os itens ao mesmo tempo, causando lentidão ou travamentos em dispositivos com menos recursos.\n\nConsiderando as informações apresentadas, avalie as asserções a seguir e a relação proposta entre elas:\n\nI. O <FlatList> é o componente mais adequado para exibir listas grandes em React Native.\n**PORQUE**\nII. Ele utiliza renderização sob demanda, o que evita o carregamento simultâneo de todos os itens da lista.\n\nA respeito dessas asserções, assinale a opção correta:",
                options: [
                    "A) As asserções I e II são proposições verdadeiras, e a II é uma justificativa correta da I.",
                    "B) As asserções I e II são proposições verdadeiras, mas a II não é uma justificativa correta da I.",
                    "C) A asserção I é uma proposição verdadeira, e a II é uma proposição falsa.",
                    "D) A asserção I é uma proposição falsa, e a II é uma proposição verdadeira.",
                    "E) As asserções I e II são proposições falsas."
                ],
                answer: "A",
                explanation: "Ambas as asserções são verdadeiras, e a Asserção II (uso de renderização sob demanda) **justifica** o porquê de o `<FlatList>` ser o componente mais adequado (Asserção I) para performance em listas grandes."
            },
            {
                id: 13,
                question: "O **Expo** é uma ferramenta que facilita o desenvolvimento de aplicativos em React Native, fornecendo uma infraestrutura pronta e simplificada. Com o aplicativo Expo Go, o desenvolvedor pode testar seu app em um dispositivo real apenas escaneando um QR Code, sem necessidade de compilar ou configurar emuladores. Isso é particularmente útil para iniciantes e projetos que priorizam agilidade, como MVPs.\n\nConsiderando as informações apresentadas, avalie as asserções a seguir e a relação proposta entre elas:\n\nI. O Expo é uma ferramenta indicada para iniciantes por simplificar o processo de execução e testes de aplicativos.\n**PORQUE**\nII. Com o Expo Go, é possível visualizar o aplicativo no celular em tempo real, sem necessidade de compilar o projeto.\n\nA respeito dessas asserções, assinale a opção correta:",
                options: [
                    "A) As asserções I e II são proposições verdadeiras, e a II é uma justificativa correta da I.",
                    "B) As asserções I e II são proposições verdadeiras, mas a II não é uma justificativa correta da I.",
                    "C) A asserção I é uma proposição verdadeira, e a II é uma proposição falsa.",
                    "D) A asserção I é uma proposição falsa, e a II é uma proposição verdadeira.",
                    "E) As asserções I e II são proposições falsas."
                ],
                answer: "A",
                explanation: "Ambas as asserções são verdadeiras, e a Asserção II (visualização em tempo real sem compilação) **justifica** o porquê de a Asserção I (ser indicada para iniciantes) ser verdadeira, devido à simplificação do processo."
            },
            {
                id: 14,
                question: "O hook **useState** é utilizado em componentes funcionais do React Native para criar e gerenciar estados internos. Quando o valor armazenado no useState muda, o componente é re-renderizado automaticamente, refletindo a nova informação na interface. Esse comportamento reativo permite a construção de aplicativos mais dinâmicos e interativos, sem a necessidade de manipulações manuais do DOM ou do layout.\n\nConsiderando as informações apresentadas, avalie as asserções a seguir e a relação proposta entre elas:\n\nI. O useState permite o controle de variáveis que mudam ao longo da execução da aplicação, re-renderizando o componente ao detectar mudanças.\n**PORQUE**\nII. O hook useState retorna um par de valores: a variável de estado e a função responsável por atualizá-la.\n\nA respeito dessas asserções, assinale a opção correta:",
                options: [
                    "A) As asserções I e II são proposições verdadeiras, e a II é uma justificativa correta da I.",
                    "B) As asserções I e II são proposições verdadeiras, mas a II não é uma justificativa correta da I.",
                    "C) A asserção I é uma proposição verdadeira, e a II é uma proposição falsa.",
                    "D) A asserção I é uma proposição falsa, e a II é uma proposição verdadeira.",
                    "E) As asserções I e II são proposições falsas."
                ],
                answer: "B",
                explanation: "Ambas as asserções são verdadeiras. No entanto, a Asserção II (o que o useState retorna) **descreve a sintaxe** do hook, mas não é a razão direta pela qual ele causa a re-renderização (que é o que a Asserção I afirma)."
            },
            {
                id: 15,
                question: "No React Native, o componente **<TouchableOpacity>** é uma alternativa ao <Button> para criação de botões personalizados. Ele permite o controle total do estilo visual e oferece feedback visual ao usuário, reduzindo a opacidade do componente durante o toque. Isso o torna ideal para interfaces que exigem mais controle estético ou interação visual refinada, como em aplicativos de design moderno ou com branding específico.\n\nConsiderando as informações apresentadas, avalie as asserções a seguir e a relação proposta entre elas:\n\nI. O <TouchableOpacity> é preferido ao <Button> quando há necessidade de personalização visual no botão.\n**PORQUE**\nII. Ele permite aplicar estilos personalizados e fornece feedback visual ao reduzir a opacidade no momento do toque.\n\nA respeito dessas asserções, assinale a opção correta:",
                options: [
                    "A) As asserções I e II são proposições verdadeiras, e a II é uma justificativa correta da I.",
                    "B) As asserções I e II são proposições verdadeiras, mas a II não é uma justificativa correta da I.",
                    "C) A asserção I é uma proposição verdadeira, e a II é uma proposição falsa.",
                    "D) A asserção I é uma proposição falsa, e a II é uma proposição verdadeira.",
                    "E) As asserções I e II são proposições falsas."
                ],
                answer: "A",
                explanation: "Ambas as asserções são verdadeiras, e a Asserção II (capacidade de estilo e feedback visual) **justifica** o porquê de o `<TouchableOpacity>` ser preferido para personalização (Asserção I)."
            },
            {
                id: 16,
                question: "A construção de interfaces gráficas em React Native exige o uso de componentes capazes de organizar os elementos visuais de forma coesa e adaptável. O sistema de layout **Flexbox** é adotado como padrão e oferece diversas propriedades para alinhar, distribuir e redimensionar os componentes. Entre essas propriedades, *justifyContent* é usada para definir o alinhamento dos itens no eixo principal, enquanto *alignItems* controla o alinhamento no eixo secundário. Já a propriedade *flex* determina como o componente cresce ou encolhe em relação aos demais. A combinação dessas propriedades permite criar interfaces responsivas que funcionam bem em diferentes tamanhos de tela.\n\nCom base no texto, qual das propriedades abaixo é usada para alinhar os elementos no **eixo principal** em Flexbox?",
                options: [
                    "A) alignltems",
                    "B) padding",
                    "C) justifyContent",
                    "D) marginTop",
                    "E) flexGrow"
                ],
                answer: "C",
                explanation: "O `justifyContent` controla o alinhamento ao longo do **eixo principal** do contêiner Flexbox. `alignItems` controla o eixo secundário (transversal)."
            },
            {
                id: 17,
                question: "O React Native permite a construção de aplicativos móveis com uma abordagem declarativa e baseada em componentes. Entre os componentes essenciais para exibição de listas de dados está o **<FlatList>**. Ele permite renderizar grandes conjuntos de dados de forma otimizada, utilizando renderização sob demanda (*lazy loading*). Essa técnica garante que apenas os itens visíveis na tela sejam carregados, economizando recursos do dispositivo e aumentando a performance. O <FlatList> também suporta cabeçalhos, rodapés, separadores e ações de rolagem infinita, sendo uma ferramenta poderosa para aplicativos que exibem muitos dados.\n\nCom base no texto, o <FlatList> é mais indicado quando:",
                options: [
                    "A) Há poucos dados e o layout é fixo.",
                    "B) O objetivo é criar navegação entre telas.",
                    "C) É necessário renderizar grandes quantidades de dados de forma performática.",
                    "D) É preciso capturar gestos e eventos de toque personalizados.",
                    "E) O aplicativo não utiliza listas, mas apenas elementos estáticos."
                ],
                answer: "C",
                explanation: "O `<FlatList>` é otimizado para lidar com **grandes conjuntos de dados** usando virtualização, garantindo alta performance."
            },
            {
                id: 18,
                question: "Em React Native, o componente **<Button>** é utilizado para permitir interações básicas com o usuário, como o envio de informações, abertura de telas ou disparo de alertas. Ele é simples e direto, sendo ideal para ações padronizadas e rápidas. Um uso comum em aplicações introdutórias é a combinação do <Button> com a função **Alert.alert()**, que exibe uma caixa de diálogo com uma mensagem ao usuário. Esse tipo de interação é muito usado para confirmar ações, avisar sobre erros ou informar o resultado de alguma operação.\n\nConsiderando o contexto apresentado, qual função é frequentemente usada com <Button> para exibir mensagens ao usuário?",
                options: [
                    "A) setTimeout()",
                    "B) console.log()",
                    "C) Alert.alert()",
                    "D) fetch()",
                    "E) useEffect()"
                ],
                answer: "C",
                explanation: "A função `Alert.alert()` é usada no React Native para exibir uma **caixa de diálogo/alerta** na interface do usuário."
            },
            {
                id: 19,
                question: "Durante o desenvolvimento de um aplicativo React Native com **Expo**, o ponto de entrada padrão do projeto é representado pelo arquivo **App.js**. Esse arquivo contém o componente principal, responsável por renderizar a interface inicial do aplicativo. O Expo reconhece esse arquivo automaticamente, sem necessidade de configurações manuais ou scripts de inicialização adicionais. Isso facilita o início do desenvolvimento, especialmente para iniciantes ou em ambientes de prototipagem rápida. O App.js pode conter rotas, contextos ou chamadas a outros componentes, servindo como a base da aplicação.\n\nQual é o arquivo de entrada padrão reconhecido automaticamente pelo Expo em um projeto React Native?",
                options: [
                    "A) MainActivity.java",
                    "B) index.html",
                    "C) App.js",
                    "D) Main.js",
                    "E) Home.tsx"
                ],
                answer: "C",
                explanation: "O Expo e o React Native (sempre que não há configurações específicas) reconhecem o arquivo **App.js** como o ponto de entrada padrão da aplicação."
            },
            {
                id: 20,
                question: "O React Native oferece hooks como *useEffect* e **useState** para facilitar o gerenciamento de ciclo de vida e de estado dos componentes. O useState, em especial, é utilizado para armazenar valores que podem mudar ao longo da execução da aplicação, como campos de formulário, contadores e seleções do usuário. Ao declarar uma variável de estado com useState, o hook retorna um array com duas posições: a primeira é o valor atual do estado, e a segunda é uma função que atualiza esse valor, disparando uma nova renderização do componente.\n\nO que o hook useState retorna quando utilizado?",
                options: [
                    "A) Uma função de ciclo de vida e um ID único",
                    "B) Uma variável de estado e sua função de atualização",
                    "C) Um componente com estilo padrão e cor de fundo",
                    "D) Uma função assíncrona e um array de valores",
                    "E) Um objeto contendo eventos de toque do usuário"
                ],
                answer: "B",
                explanation: "O `useState` retorna um array com a **variável de estado atual** (`valor`) e uma **função para atualizar esse estado** (`setValor`)."
            }
        ];

        let currentQuestionIndex = 0;
        let score = 0;
        let isAnswered = false; // Flag para evitar múltiplos cliques

        const questionTextEl = document.getElementById('question-text');
        const optionsContainerEl = document.getElementById('options-container');
        const progressTextEl = document.getElementById('progress-text');
        const progressBarEl = document.getElementById('progress-bar');
        const nextButtonEl = document.getElementById('next-button');
        const feedbackToastEl = document.getElementById('feedback-toast');
        const feedbackMessageEl = document.getElementById('feedback-message');
        const toastButtonEl = document.getElementById('toast-button');
        const finishModalEl = document.getElementById('finish-modal');
        const finalScoreEl = document.getElementById('final-score');
        const finalMaxScoreEl = document.getElementById('final-max-score');
        const finalTotalQuestionsEl = document.getElementById('final-total-questions');


        /**
         * Gera e renderiza a questão atual na interface.
         */
        function renderQuestion() {
            const questionData = quizData[currentQuestionIndex];
            isAnswered = false;
            
            // Oculta o botão de próxima questão
            nextButtonEl.classList.add('opacity-0', 'pointer-events-none');
            nextButtonEl.classList.remove('opacity-100');

            // 1. Atualiza o texto da questão. Usamos innerHTML para reconhecer a tag <br> no texto.
            questionTextEl.innerHTML = `<span>${questionData.question}</span>`;

            // 2. Atualiza o progresso visual
            const totalQuestions = quizData.length;
            const progress = (currentQuestionIndex + 1) / totalQuestions;
            progressBarEl.style.width = `${progress * 100}%`;
            progressTextEl.textContent = `Questão ${currentQuestionIndex + 1} de ${totalQuestions}`;

            // 3. Renderiza as opções
            optionsContainerEl.innerHTML = '';
            questionData.options.forEach((option, index) => {
                const optionLetter = String.fromCharCode(65 + index); // A, B, C, ...
                const button = document.createElement('button');
                
                button.setAttribute('data-answer', optionLetter);
                // Adiciona 'whitespace-pre-line' aqui para preservar quebras de linha nas opções, se houver.
                button.classList.add('option-button', 'w-full', 'p-4', 'text-left', 'bg-slate-700', 'rounded-lg', 'font-medium', 'text-sm', 'sm:text-base', 'transition-all', 'duration-200', 'hover:bg-slate-600', 'shadow-md', 'whitespace-pre-line');
                button.innerHTML = `<span>${option}</span>`;
                button.onclick = () => checkAnswer(button, optionLetter);
                
                optionsContainerEl.appendChild(button);
            });
            
            // Oculta o Toast caso esteja visível
            hideToast();
        }

        /**
         * Verifica a resposta selecionada pelo usuário.
         * @param {HTMLElement} selectedButton - O botão clicado.
         * @param {string} selectedAnswer - A letra da resposta selecionada (A, B, C...).
         */
        function checkAnswer(selectedButton, selectedAnswer) {
            if (isAnswered) return;
            isAnswered = true;

            const questionData = quizData[currentQuestionIndex];
            const isCorrect = selectedAnswer === questionData.answer;
            const correctButton = Array.from(optionsContainerEl.children).find(btn => btn.getAttribute('data-answer') === questionData.answer);

            // Desabilita todos os botões de opção
            Array.from(optionsContainerEl.children).forEach(btn => btn.setAttribute('disabled', 'true'));
            
            // 1. Aplica o estilo de feedback ao botão clicado
            if (isCorrect) {
                score++;
                selectedButton.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                selectedButton.classList.add('bg-emerald-600', 'hover:bg-emerald-600', 'shadow-emerald-900/50', 'shadow-xl');
                showToast(true, "Correto! Excelente. Avançando para a próxima...", "Continuar");
            } else {
                selectedButton.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                selectedButton.classList.add('bg-red-500', 'shadow-red-900/50', 'shadow-xl');
                
                // 2. Destaca a resposta correta e mostra o feedback de erro
                if (correctButton) {
                    correctButton.classList.add('correct-answer-highlight');
                }
                
                // Usa <br> para quebras de linha no feedback, garantindo legibilidade
                const message = `<span class="font-extrabold">Incorreto.</span> A resposta correta era **${questionData.answer}**.<br><br> ${questionData.explanation}`;
                showToast(false, message, "Entendi");
            }

            // 3. Mostra o botão de próxima questão após o feedback
            setTimeout(() => {
                nextButtonEl.classList.remove('opacity-0', 'pointer-events-none');
                nextButtonEl.classList.add('opacity-100');
            }, isCorrect ? 500 : 2500); // Mostra mais rápido se estiver correto.
        }

        /**
         * Avança para a próxima questão ou finaliza o quiz.
         */
        function nextQuestion() {
            currentQuestionIndex++;
            hideToast();

            if (currentQuestionIndex < quizData.length) {
                renderQuestion();
            } else {
                showFinalResults();
            }
        }
        
        /**
         * Exibe o modal com os resultados finais.
         */
        function showFinalResults() {
            finalScoreEl.textContent = score;
            finalMaxScoreEl.textContent = quizData.length;
            finalTotalQuestionsEl.textContent = quizData.length;
            finishModalEl.classList.remove('hidden');
            finishModalEl.classList.add('flex');
            document.getElementById('app-container').classList.add('hidden'); // Oculta o quiz
        }
        
        /**
         * Reinicia o quiz.
         */
        function restartQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            finishModalEl.classList.remove('flex');
            finishModalEl.classList.add('hidden');
            document.getElementById('app-container').classList.remove('hidden');
            renderQuestion();
        }

        /**
         * Exibe o Toast de feedback personalizado.
         * @param {boolean} isCorrect - Se a resposta foi correta.
         * @param {string} message - A mensagem de feedback.
         * @param {string} buttonText - O texto do botão no Toast.
         */
        function showToast(isCorrect, message, buttonText) {
            feedbackToastEl.classList.remove('bg-emerald-600', 'bg-red-500');
            
            if (isCorrect) {
                feedbackToastEl.classList.add('bg-emerald-600');
                feedbackMessageEl.classList.add('text-white');
                toastButtonEl.classList.add('bg-white', 'text-emerald-700');
                toastButtonEl.classList.remove('bg-white/10', 'text-red-100', 'hidden');
                toastButtonEl.textContent = buttonText;
                
            } else {
                feedbackToastEl.classList.add('bg-red-500');
                feedbackMessageEl.classList.add('text-white');
                toastButtonEl.classList.add('bg-white/10', 'text-red-100');
                toastButtonEl.classList.remove('bg-white', 'text-emerald-700', 'hidden');
                toastButtonEl.textContent = buttonText;
            }
            
            feedbackMessageEl.innerHTML = message;
            feedbackToastEl.classList.add('show');
            
            // Oculta o Toast automaticamente se a resposta estiver correta
            if (isCorrect) {
                setTimeout(hideToast, 2000);
            }
        }
        
        /**
         * Oculta o Toast de feedback.
         */
        function hideToast() {
            feedbackToastEl.classList.remove('show');
            // Remove as classes de cor e texto para redefinição
            feedbackToastEl.classList.remove('bg-emerald-600', 'bg-red-500');
            feedbackMessageEl.classList.remove('text-white');
            toastButtonEl.classList.add('hidden');
        }

        // Inicia o quiz ao carregar a página
        window.onload = renderQuestion;

    </script>
</body>
</html>

